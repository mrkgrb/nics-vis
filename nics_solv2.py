"""
This script generates differential 2D NICS maps (PNG format) for compounds in either:  
    • two selected solvents, or  
    • singlet (S0) vs. triplet (T1) states.  

It detects suitable pairs of Gaussian *.log files in the working directory.  
Log files must contain the string "NMP" and should originate from input files generated by nics2d.py.  

For solvent differential maps, the filenames must include solvent abbreviations:  
    "DCM"  – dichloromethane  
    "ACN"  – acetonitrile  
    "Hex"  – n-hexane  
    "H2O"  – water  
    "MeOH" – methanol  
    "Tol"  – toluene  
    "Vac"  – vacuum  

The script automatically corrects NICS(h)zz values for tilted rings by rotating the magnetic shielding tensor.  

For singlet–triplet differential maps, filenames must contain `NMP` (singlet) and `tNMP` (triplet):  
    [compound name]-[solvent abbreviation]-NMP.log     → singlet (S0)  
    [compound name]-[solvent abbreviation]-tNMP.log    → triplet (T1)  
Example: Pentacene-DCM-NMP.log and Pentacene-DCM-tNMP.log  
→ generates a singlet–triplet differential map.  

For solvent differential maps, example:  
    Pentacene-Hex-NMP.log and Pentacene-MeOH-NMP.log  
→ generates a Hex–MeOH differential map (default pair).  

Other solvent pairs can be specified with `--sv1` and `--sv2` using the abbreviations above, e.g.:  
    python nics_solv.py --sv1 "DCM" --sv2 "H2O"  
→ generates a DCM–H2O differential map.  

For usage:  
    python nics_solv.py --help
"""

import os
import re
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use("Agg")
from scipy.interpolate import griddata
from matplotlib.colors import LinearSegmentedColormap, Normalize
from matplotlib.colorbar import ColorbarBase
from matplotlib.gridspec import GridSpec
import argparse



# Function to parse coordinates from the input orientation section
def parse_coordinates(filepath):
    bq_pattern = re.compile(
    r"^\s*Bq\s+(-?\d+(?:\.\d*)?)\s+(-?\d+(?:\.\d*)?)\s+(-?\d+(?:\.\d*)?)\s*$"
    )
    
    atom_pattern = re.compile(
    r"^\s*([A-Z][a-z]?)\s+(-?\d+(?:\.\d*)?)\s+(-?\d+(?:\.\d*)?)\s+(-?\d+(?:\.\d*)?)\s*$"
    )
    
    dipole_pattern = re.compile(
    r"\s+X=\s+(-?\d+\.\d+)\s+Y=\s+(-?\d+\.\d+)\s+Z=\s+(-?\d+\.\d+)"    
    )
    
    bq_coordinates = []
    at_coordinates = []
    at_types = []
    dipole_moment = [0,0,0]
    with open(filepath, 'r') as file:
        for line in file:
            match = bq_pattern.match(line)
            if match:
                x, y, z = map(float, match.groups())
                bq_coordinates.append(np.array([x, y, z]))
            else:
                match = atom_pattern.match(line)
                if match:
                    at, x, y, z = match.groups()
                    at_coordinates.append(np.array([float(x), float(y), float(z)]))
                    at_types.append(at)
                else:
                    match = dipole_pattern.match(line)
                    if match:
                        x, y, z = map(float, match.groups())
                        dipole_moment = [x,y,z]
                    
    numa = len(bq_coordinates)
    numa_zwei = len(at_coordinates)
    print(f"Atomic coords: {numa_zwei}, Bq coords: {numa}")  
    print(f"Dipole moment: X={dipole_moment[0]:.3f}, Y={dipole_moment[1]:.3f}, Z={dipole_moment[2]:.3f}")
    return bq_coordinates, at_coordinates, at_types, dipole_moment
     
def round_to_nearest_in_list(x):
    """
    Rounds a value to the closest value in a given list.
    
    Args:
        x (float): The value to round.
        values (list of float): The list of possible values to round to.
    
    Returns:
        float: The rounded value.
    """
    values = [0.1, 0.2, 0.25, 0.5, 1, 2, 2.5, 5, 10, 20]
    return min(values, key=lambda v: abs(x - v))

def create_colored_map_with_coords(results, results2, filename, pix_per_angstrom, colors, vmin, vmax, coords, bonds, atom_colors, atom_sizes, iso_cont, nics_r, d_type, ticks_num, linew, no_legend, iso_not_zz, dipole_moments, or_atm, spec_atom, separated_fig=False):
    """
    Creates a colored 2D map of the "avg_zz_tilted" parameter from the "results" table 
    and overlays molecular coordinates with customizable colors and sizes.

    """
    # Extract data
    x = np.array([result["X_proj"] for result in results])
    y = np.array([result["Y_proj"] for result in results])
    if not iso_not_zz: 
        z = np.array([result["avg_zz_tilted"] for result in results])
    else:
        z = np.array([result["avg_iso"] for result in results])
    
    x2 = np.array([result["X_proj"] for result in results2])
    y2 = np.array([result["Y_proj"] for result in results2])
    if not iso_not_zz: 
        z2 = np.array([result["avg_zz_tilted"] for result in results2])
    else:
        z2 = np.array([result["avg_iso"] for result in results2])

    #reorient so the spec_atom is in lower left part (if there is one spec_atom)
    N_number = 0 

    for cor in coords:

        if cor[0] == spec_atom:
            N_number += 1
            nitro_coords = ((cor[1],cor[2]))
            
    New_coords = []
    if np.linalg.norm(dipole_moments[0]) > 0.5 and not or_atm:
        xs = float(1.0)
        ys = float(1.0)
        
        if dipole_moments[0][0] > 0:
            x = -x
            #x2 = -x2
            xs = -xs
            dipole_moments[0][0] = -dipole_moments[0][0]
            
        if dipole_moments[1][0] > 0:
            #x = -x
            x2 = -x2
            #xs = -xs
            dipole_moments[1][0] = -dipole_moments[1][0]
                 
        if dipole_moments[0][1] > 0:
            y = -y
            #y2 = -y2
            ys = -ys
            dipole_moments[0][1] = -dipole_moments[0][1]
            
        if dipole_moments[1][1] > 0:
            #y = -y
            y2 = -y2
            #ys = -ys
            dipole_moments[1][1] = -dipole_moments[1][1]
            
        for cor in coords:
            New_coords.append((cor[0] , xs*cor[1] , ys*cor[2]))
        coords = New_coords
    else:
        if N_number >= 1:
            N_vec_x = nitro_coords[0] - x.mean(axis=0)
            N_vec_y = nitro_coords[1] - y.mean(axis=0)
            xs = float(1.0)
            ys = float(1.0)
            
            if N_vec_x > 0:
                x = -x
                x2 = -x2
                xs = -xs
                dipole_moments[0][0] = -dipole_moments[0][0]
                dipole_moments[1][0] = -dipole_moments[1][0]
                     
            if N_vec_y > 0:
                y = -y
                y2 = -y2
                ys = -ys
                dipole_moments[0][1] = -dipole_moments[0][1]
                dipole_moments[1][1] = -dipole_moments[1][1]
                
            for cor in coords:
                New_coords.append((cor[0] , xs*cor[1] , ys*cor[2]))
                
            coords = New_coords
            
    # Create a custom colormap from the given colors
    N = 256 * len(colors)
    
    xspan = x.max() - x.min()
    yspan = y.max() - y.min()
    
    cmap = LinearSegmentedColormap.from_list("custom_cmap", colors, N=N)
    
    
    image_width = int(float(pix_per_angstrom * xspan))
    scaling_factor = float(float(pix_per_angstrom) / 90.0)
    image_height = int(float(image_width) * yspan / xspan)
    print(f"X span: {xspan:.2f} A, Y span: {yspan:.2f} A, W/H {image_width}/{image_height} pix")

    # Interpolate data onto a grid using Delaunay triangulation for efficiency
    grid_x, grid_y = np.linspace(x.min(), x.max(), image_width), np.linspace(
        y.min(), y.max(), int(image_height)
    )

    grid_x2, grid_y2 = np.linspace(x.min(), x.max(), image_width), np.linspace(
        y.min(), y.max(), int(image_height)
    )
       
    dpi = 150
    desired_w_px = int(image_width)    
    desired_h_px = int(image_height) 
    
    grid_z = griddata((x, y), z, (grid_x[None, :], grid_y[:, None]), method="cubic")
    grid_z2 = griddata((x2, y2), z2, (grid_x2[None, :], grid_y2[:, None]), method="cubic")    
        
    ticks_cor = []
    ticks_val = []
    span = float(vmax - vmin)
    delta = 0.5 * span / float(ticks_num)
    delta = round_to_nearest_in_list(delta)
        
    n_ticks = int(0.5 * span/delta)
    span = 2 * delta * float(n_ticks)
        
    n_rest = int(10 * delta) % 10
    vmin = -delta * float(n_ticks)
    vmax = -vmin
    for t in np.linspace(0, 1,int(2 * n_ticks + 1)):
        ticks_cor.append(t)
        val = vmin + t * span
        if n_rest > 0: 
            ticks_val.append(f"{val:.1f}") 

        else: ticks_val.append(f"{val:.0f}")
  
    
    grid_z = (grid_z2 - grid_z)
    grid_z = (grid_z - vmin) / (vmax - vmin)
    grid_z = np.clip(grid_z, 0, 1)
    
    # Create the plot
    if int(nics_r * 10) % 10 > 0:
        nics_type = f"NICS({nics_r:.1f})zz"
    else: nics_type = f"NICS({nics_r:.0f})zz"
    if iso_not_zz:
        nics_type = nics_type.replace("zz", "iso")
    
    #stringi
    if d_type == "st": d_type_str = "S0-T1" 
    elif d_type == "pol": d_type_str = "polarity"
    
    # choose filenames
    root, ext = os.path.splitext(filename)
    map_fn = f"{root}_map{ext}" if separated_fig else filename
    cbar_fn = f"{root}_map_bar{ext}"
    
    if separated_fig:
        # Map-only: make axes fill the canvas to get exact desired pixel size
        fig = plt.figure(figsize=(desired_w_px/dpi, desired_h_px/dpi), dpi=dpi)
        ax = fig.add_axes([0, 0, 1, 1])                  # full-bleed
        im = ax.imshow(grid_z, extent=(x.min(), x.max(), y.min(), y.max()),
                       origin="lower", cmap=cmap, aspect="auto", vmin=0, vmax=1)
        if iso_cont:
            ax.contour(grid_x, grid_y, grid_z, levels=ticks_cor, colors="#EEEEEE", linewidths=linew*scaling_factor)
    
        # draw bonds/atoms/dipole on ax exactly as before (using ax.* instead of plt.*)
        # bonds
        for bond in bonds:
            _, x1, y1 = coords[bond[0]]
            _, x2, y2 = coords[bond[1]]
            if (grid_x.min() <= x1 <= grid_x.max()) and (grid_y.min() <= y1 <= grid_y.max()) and (grid_x.min() <= x2 <= grid_x.max()) and (grid_y.min() <= y2 <= grid_y.max()):
                ax.plot([x1, x2], [y1, y2], color="black", linewidth=scaling_factor, zorder=5)
        
        # atoms
        for atom, x_coord, y_coord in coords:
            color = atom_colors.get(atom, "black")
            size = int(float(atom_sizes.get(atom, 30)) * scaling_factor)
            if (grid_x.min() <= x_coord <= grid_x.max()) and (grid_y.min() <= y_coord <= grid_y.max()):
                ax.scatter(x_coord, y_coord, color=color, s=size, label=atom,linewidth=scaling_factor,  edgecolor='black', zorder=10)
        
        
        
        ax.set_axis_off()                                # no ticks/labels/border
        fig.savefig(map_fn, dpi=dpi, bbox_inches=None, pad_inches=0)
        print(f"Saved: {map_fn}")
        plt.close(fig)
    
        # Standalone colorbar: choose your own pixel size; independent of map
        cb_w_px = 150                       # slim bar; adjust if you like
        cb_h_px = desired_h_px
        fig_cb, ax_cb = plt.subplots(
            figsize=(cb_w_px/dpi, cb_h_px/dpi),
            dpi=dpi,
            layout="constrained"            # prevents label clipping
        )
        
        norm = Normalize(vmin=0, vmax=1)
        cb = ColorbarBase(ax_cb, cmap=cmap, norm=norm, orientation='vertical', ticks=ticks_cor)
        
        # put tick labels on the RIGHT; hide left so it's clean, like combined
        cb.ax.tick_params(labelright=True, labelleft=False, right=True, left=False)
        cb.set_label(nics_type)             # same label as combined
        cb.ax.set_yticklabels(ticks_val)    # same tick strings as combined
        
        # save without cropping the right-edge labels
        fig_cb.savefig(cbar_fn, dpi=dpi, bbox_inches="tight", pad_inches=0.02)
        print(f"Saved: {cbar_fn}\n")
        plt.close(fig_cb)
    
    else:
        # Combined: size the figure so that the MAP AXES area ends up with the same pixel size
        # Choose fractions for left/bottom margins and colorbar width
        left, right, bottom, top = 0.08, 0.92, 0.10, 0.92
        cbar_frac = 0.03                                   # colorbar axes width as fraction of figure
        map_w_frac = right - left - cbar_frac              # fraction available for the map axes
        map_h_frac = top - bottom
    
        # Figure size so that map axes (not whole figure) match desired pixels
        fig_w_in = desired_w_px / (dpi * map_w_frac)
        fig_h_in = desired_h_px / (dpi * map_h_frac)
    
        fig = plt.figure(figsize=(fig_w_in, fig_h_in), dpi=dpi)
        gs = GridSpec(nrows=1, ncols=2, width_ratios=[map_w_frac, cbar_frac], wspace=0.02)
        fig.subplots_adjust(left=left, right=right, bottom=bottom, top=top)
    
        ax = fig.add_subplot(gs[0, 0])
        im = ax.imshow(grid_z, extent=(x.min(), x.max(), y.min(), y.max()),
                       origin="lower", cmap=cmap, aspect="auto", vmin=0, vmax=1)
        if iso_cont:
            ax.contour(grid_x, grid_y, grid_z, levels=ticks_cor, colors="#EEEEEE", linewidths=linew * scaling_factor)
    
        # bonds/atoms/dipole on ax (use ax.plot / ax.scatter / ax.arrow)
        # bonds
        for bond in bonds:
            _, x1, y1 = coords[bond[0]]
            _, x2, y2 = coords[bond[1]]
            if (grid_x.min() <= x1 <= grid_x.max()) and (grid_y.min() <= y1 <= grid_y.max()) and (grid_x.min() <= x2 <= grid_x.max()) and (grid_y.min() <= y2 <= grid_y.max()):
                ax.plot([x1, x2], [y1, y2], color="black", linewidth=scaling_factor, zorder=5)
        
        # atoms
        for atom, x_coord, y_coord in coords:
            color = atom_colors.get(atom, "black")
            size = int(float(atom_sizes.get(atom, 30)) * scaling_factor)
            if (grid_x.min() <= x_coord <= grid_x.max()) and (grid_y.min() <= y_coord <= grid_y.max()):
                ax.scatter(x_coord, y_coord, color=color, s=size, label=atom, linewidth=scaling_factor, edgecolor='black', zorder=10)
        

        # labels/legend
        ax.set_title(f"2D {nics_type} {d_type_str} differential map")
        ax.set_xlabel("X (Å)")
        ax.set_ylabel("Y (Å)")
        ax.set_aspect("equal", adjustable="box")
    
        # colorbar bound to imshow on its own axes
        cax = fig.add_subplot(gs[0, 1])
        cbar = fig.colorbar(im, cax=cax)
        cbar.set_ticks(ticks_cor)
        cbar.set_ticklabels(ticks_val)
        cbar.set_label(nics_type)
        
        fig.savefig(map_fn, dpi=dpi, bbox_inches=None, pad_inches=0)  # no tight, no cropping
        print(f"Saved: {map_fn}\n")
        plt.close(fig)
        
"""
    plt.figure(figsize=(float(image_width) / float(150), float(image_height) / float(150)))  # Convert pixels to inches for figsize
    plt.imshow(grid_z, extent=(x.min(), x.max(), y.min(), y.max()), origin="lower", cmap=cmap, aspect="auto", vmin=0, vmax=1)
    cbar = plt.colorbar(label=nics_type)
  
    # Add contour lines
    if iso_cont:
        contours = plt.contour(grid_x, grid_y, grid_z, levels=ticks_cor, colors="#DDDDDD", linewidths=linew)

    cbar.set_ticks(ticks_cor)

    cbar.set_ticklabels(ticks_val)
    
    if d_type == "st": d_type_str = "S0-T1" 
    elif d_type == "pol": d_type_str = "polarity"
    plt.title(f"2D {nics_type} {d_type_str} differential map")
    plt.xlabel("X (Å)")
    plt.ylabel("Y (Å)")
    plt.gca().set_aspect("equal", adjustable="box")

    for bond in bonds:
        _, x1, y1 = coords[bond[0]]
        _, x2, y2 = coords[bond[1]]
        if(grid_x.min() <= x1 <= grid_x.max()) and (grid_y.min() <= y1 <= grid_y.max()) and (grid_x.min() <= x2 <= grid_x.max()) and (grid_y.min() <= y2 <= grid_y.max()):
            plt.plot([x1, x2], [y1, y2], color="black", linewidth=0.5, zorder=5)   
    
    # Overlay molecular coordinates
    for atom, x_coord, y_coord in coords:
        color = atom_colors.get(atom, "black")  # Default to black if atom type is not in the dictionary
        size = atom_sizes.get(atom, 30)        # Default size of 30 if atom type is not in the dictionary
        if(grid_x.min() <= x_coord <= grid_x.max()) and (grid_y.min() <= y_coord <= grid_y.max()):
            plt.scatter(x_coord, y_coord, color=color, s=size, label=atom, edgecolor='black', zorder=10)

    
    # Avoid repeating labels in the legend
    handles, labels = plt.gca().get_legend_handles_labels()
    unique = dict(zip(labels, handles))
    if not no_legend:
        plt.legend(unique.values(), unique.keys(), loc="upper right", fontsize="medium")

    # Save the figure as a PNG file
    plt.savefig(filename, dpi=150, bbox_inches="tight")
    print(f"Saved: {filename}\n")
    plt.close()
"""
   
# Function to parse shielding tensors from Gaussian log files
def parse_shielding_data(filepath):
    with open(filepath, 'r') as file:
        content = file.read()

    # Regular expression to find Bq atom data (shielding tensors)
    bq_pattern = re.compile(
        r"\s+(\d+)\s+Bq\s+Isotropic\s+=\s+([\d\-.]+)\s+Anisotropy\s+=\s+[\d\-.]+.*?"
        r"XX=\s+([\d\-.]+)\s+YX=\s+([\d\-.]+)\s+ZX=\s+([\d\-.]+).*?"
        r"XY=\s+([\d\-.]+)\s+YY=\s+([\d\-.]+)\s+ZY=\s+([\d\-.]+).*?"
        r"XZ=\s+([\d\-.]+)\s+YZ=\s+([\d\-.]+)\s+ZZ=\s+([\d\-.]+)",
        re.DOTALL
    )

    bq_data = []
    for match in bq_pattern.finditer(content):
        atom_index = int(match.group(1))
        isotropic = float(match.group(2))
        tensor = np.array([
            [float(match.group(3)), float(match.group(4)), float(match.group(5))],
            [float(match.group(6)), float(match.group(7)), float(match.group(8))],
            [float(match.group(9)), float(match.group(10)), float(match.group(11))]
        ])
        bq_data.append((atom_index, isotropic, tensor))
        
    numa = len(bq_data)
    print(f"Shielding data: {numa}")     
    return bq_data


# Function to calculate tilt-adjusted shielding
def calculate_tilted_shielding(bq_data,coords):
    results = []

    avg_con_vec_len = 0
    n_bq_pairs = 0
    
    for i in range(0, len(bq_data), 2):
        # Extract data for the Bq atom pair
        _, iso1, tensor1 = bq_data[i]
        _, iso2, tensor2 = bq_data[i + 1]
        coords1 = coords[i]
        coords2 = coords[i + 1]
        
        # Calculate vector connecting the pair and normalize it
        connecting_vector = coords2 - coords1
        con_vec_len = np.linalg.norm(connecting_vector)
        norm_vector = connecting_vector / con_vec_len
        avg_con_vec_len += con_vec_len
        # Calculate the central position between the Bq points
        centroid = (coords1 + coords2) / 2
        x_pr = np.dot(centroid,[1,0,0])
        y_pr = np.dot(centroid,[0,1,0])

        # Calculate the isotropic shielding and adjusted ZZ component
        avg_iso = -0.5 * (iso1 + iso2)
          
        # Adjust the ZZ components
        zz1 = norm_vector @ tensor1 @ norm_vector
        zz2 = norm_vector @ tensor2 @ norm_vector
        avg_zz_tilted = -0.5 * (zz1 + zz2)
        
        zz1 = -0.5*(tensor1[2][2] + tensor2[2][2])
        # Add the path length contribution

        results.append({
            "X_proj": x_pr,
            "Y_proj": y_pr,
            "avg_iso": avg_iso,
            "avg_zz_tilted": avg_zz_tilted,
            "avg_zz_original": zz1
        })
        n_bq_pairs += 1
        
    if n_bq_pairs > 0:
        avg_con_vec_len /= n_bq_pairs * 2
    
    return results, avg_con_vec_len

# Function to write the output file
def write_results(filepath, results):
    output_file = filepath.replace(".log", ".txt")
    num_bq = 2 * len(results)
    # avg_step = 2 * total_path_length / num_bq
    with open(output_file, 'w') as file:
        file.write(f"Bq points: {num_bq}\n")
        file.write("\nX_proj Y_proj NICS_iso NICS_ZZ_tilted NICS_ZZ_original\n")
        for result in results:
            file.write(f"{result['X_proj']:.6f} {result['Y_proj']:.6f} {result['avg_iso']:.6f} {result['avg_zz_tilted']:.6f} {result['avg_zz_original']:.6f}\n")
        print(f"Saved file: {output_file}")
        
# Main script
input_folder = "."  # Use current folder

    # Process all *.xyz files in the folder

parser = argparse.ArgumentParser(description="Generate a differential map based on NICS data.")
parser.add_argument("--cont-map", dest="iso_cont", action="store_true", help="Add contour map")
parser.add_argument("--no-legend", dest="no_legend", action="store_true", help="Remove legend")
parser.add_argument("--iso", dest="iso_not_zz", action="store_true", help="Calculate isotropic shielding instead of ZZ")
parser.add_argument("--m", type=float, default=8, help="Max and min NICS(h)zz values (default: 8).")
parser.add_argument("--tm", type=float, default=16, help="Max and min NICS(h)zz values for singlet-triplet difference (default: 16).")
parser.add_argument("--nt", type=int, default=8, help="Number of ticks and contour lines - the same in positive and negative direction (default: 8).")
parser.add_argument("--lw", type=float, default=0.5, help="Linewidth for contour lines (default: 0.5).")
parser.add_argument("--sv1", type=str, default="Hex", help="Enter solvent 1 abbr (default: Hex)")
parser.add_argument("--sv2", type=str, default="MeOH", help="Enter solvent 2 abbr (default: MeOH)")
parser.add_argument("--orient-atom", dest="or_atm", action="store_true", help="Orient molecule placing selected atom in bottom left corner")
parser.add_argument("--atm", type=str, default="N", help="Atom to be in bottom left corner (default: N)")
parser.add_argument("--res", type=float, default=90.0, help="Image resolution in pixels per angstrom (default: 90).")
parser.add_argument("--sep-figs", dest="sep_fig", action="store_true", help="Save clean figure area and separate colorbar")
parser.set_defaults(iso_cont=False)
parser.set_defaults(sep_fig=False)
parser.set_defaults(or_atm=False)
parser.set_defaults(iso_not_zz=False)
parser.set_defaults(no_legend=False)

args = parser.parse_args()

solvent1 = args.sv1
solvent2 = args.sv2

if args.iso_cont:
    yesno = f"be added (linewidth: {args.lw:.2f})"
else:
    yesno = "not be added"
print(f"Min and max NICS values: +/-{args.m}. Contour map will {yesno}. Number of ticks: {args.nt} (both sides). Solvents: {solvent1} and {solvent2}")

files_data = []
for filename in os.listdir(input_folder):
    nmp_yn = filename.endswith("NMP.log") or ((filename.find("-NMP")!=-1 or filename.find("-tNMP")!=-1) and filename.endswith(".log"))

    if nmp_yn:
        base_name = os.path.splitext(filename)[0]
        parts = base_name.split("-")
        molecule_name = parts[0]
        solvent_abbr = parts[1] if len(parts) > 1 else "Vac"  # Default solvent is DCM 
        s_or_t = "t" if (filename.endswith("tNMP.log") or filename.find("-tNMP")!=-1) else "s"
        files_data.append({"file": filename, "cpd": molecule_name, "slv": solvent_abbr, "st": s_or_t })
        
mol_pairs = []
diff_type = []
for i, file1 in enumerate(files_data):
    for j, file2 in enumerate(files_data):
        if i >= j:
            continue
        if file1['cpd'] == file2['cpd']:
            if file1['st'] == file2['st']:

                if (file1['slv'] == solvent2) and (file2['slv'] == solvent1):
                    mol_pairs.append((j,i))
                    diff_type.append("pol")
                    print(f"Pair: {file2['file']} and {file1['file']}")
                elif (file2['slv'] == solvent2) and (file1['slv'] == solvent1):
                    mol_pairs.append((i,j))
                    diff_type.append("pol")
                    print(f"Pair: {file1['file']} and {file2['file']}")
            elif file1['slv'] == file2['slv']:
                    if file1['st'] == "t":
                        mol_pairs.append((j,i))
                        diff_type.append("st")
                        print(f"Pair: {file2['file']} and {file1['file']}")
                    elif file2['st'] == "t":
                        mol_pairs.append((i,j))
                        diff_type.append("st")
                        print(f"Pair: {file1['file']} and {file2['file']}")                    

for pair, di_typ in zip(mol_pairs,diff_type):
    file1 = files_data[pair[0]]['file']
    file2 = files_data[pair[1]]['file']
    
    fpath1 = os.path.join(input_folder, file1)
    fpath2 = os.path.join(input_folder, file2)
    file_png = fpath1
    file_png = file_png.replace(".log", ".png")
    
    name_descr = f"{files_data[pair[0]]['slv']}-{files_data[pair[1]]['slv']}-{di_typ}-dif" if di_typ == "pol" else f"{files_data[pair[0]]['slv']}-{di_typ}-dif"
    file_png = file_png.replace(files_data[pair[0]]['slv'], name_descr)
    print(f"Opened: {file1} and {file2}")
    bq_coordinates1, at_coords1, at_types1, dipole_moment1 = parse_coordinates(fpath1)
    bq_data1 = parse_shielding_data(fpath1)
    bq_coordinates2, at_coords2, at_types2, dipole_moment2 = parse_coordinates(fpath2)
    bq_data2 = parse_shielding_data(fpath2)
    avg_dipole = [(dipole_moment1[0] + dipole_moment2[0]) / 2, (dipole_moment1[1] + dipole_moment2[1]) / 2,(dipole_moment1[2] + dipole_moment2[2]) / 2]
    
    vmin_vmax = args.tm if di_typ == "st" else args.m
    
    at_proj_coords = []
           
    for at,atty in zip(at_coords1,at_types1):
        x_pr = at[0]
        y_pr = at[1]
        at_proj_coords.append((atty,x_pr,y_pr))
   
    bond_info=[]
        
    for i, (x1, y1, z1) in enumerate(at_coords1):
        for j, (x2, y2, z2) in enumerate(at_coords1):
            if i >= j:
                continue  # Avoid double calculation

            distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)
            max_distance = 1.3 if "H" in (at_types1[i], at_types1[j]) else 1.9

            if distance <= max_distance:
                bond_info.append((i,j))
            

        # Calculate the adjusted shielding data
    if (len(bq_coordinates1) == len(bq_data1)) and (len(bq_coordinates2) == len(bq_data2)):
            shift = np.mean(at_coords1,axis=0) - np.mean(at_coords2,axis=0) 

            bq_coordinates2 = bq_coordinates2 + shift
            at_coords2 = at_coords2 + shift
                       
            results, avg_h = calculate_tilted_shielding(bq_data1,bq_coordinates1)
            results2, avg_h2 = calculate_tilted_shielding(bq_data2,bq_coordinates2)
            print(f"Average Bq elevation: {avg_h:.3f} and {avg_h2:.3f}")
            avg_h = (avg_h + avg_h2) / 2

        
    atom_colors = {
            "C": "#666666",  # Grey
            "H": "#FFFFFF",  # White
            "O": "#FF0000",  # Red
            "N": "#0000FF",  # Blue
            "S": "#FFFF00",  # Yellow
            "P": "#FFA500",  # Orange
            "Si": "#00AAAA",
            "F": "#00FF00",  # Green
            "Cl": "#00FF00",  # Green
            "Br": "#8B0000",  # Dark red
            "B": "#FFB6C1",  # Peach
    }

    default_color = "#FFC0CB"  # Pink for any other element

    atom_sizes = {
            "C": 120,
            "H": 60,
            "O": 160,
            "N": 140,
            "S": 180,
            "P": 180,
            "Si": 180,
            "F": 120,
            "Cl": 140,
            "Br": 160,
            "B": 100,
    }

    color_space = [
        (0.12, 0.03, 0.39),
        (0.03, 0.04, 0.64),
        (0.05, 0.11, 0.98),
        (0.19, 0.68, 1),
        (0.73, 0.92, 1),
        (1, 1, 1),
        (1, 0.92, 0.73),
        (1, 0.68, 0.19),
        (0.98, 0.11, 0.05),
        (0.64, 0.04, 0.03),
        (0.39, 0.03, 0.12)
    ]
            
            
    create_colored_map_with_coords(
            results,
            results2,
            file_png,
            pix_per_angstrom=args.res,
            colors=color_space,
            vmin=-vmin_vmax,
            vmax=vmin_vmax,
            coords=at_proj_coords,
            bonds=bond_info,
            atom_colors=atom_colors,
            atom_sizes=atom_sizes,
            iso_cont = args.iso_cont,
            nics_r = avg_h,
            d_type = di_typ,
            ticks_num = args.nt,
            linew = args.lw,
            no_legend = args.no_legend,
            iso_not_zz = args.iso_not_zz,
            dipole_moments = [dipole_moment1,dipole_moment2],
            or_atm = args.or_atm,
            spec_atom = args.atm,
            separated_fig = args.sep_fig
    )
