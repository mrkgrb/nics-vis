"""
This script generates 2D NICS maps (PNG format) from Gaussian *.log files in the working directory.  
Log files must contain the string "NMP" in their filename and should originate from input files generated 
by the nics2d.py script.  
Log filenames should follow the format (as generated by nics2d.py):
[compound name]-[solvent abbreviation]-NMP.log for singlet or -tNMP.log for triplet state
e.g.: Pentacene-DCM-NMP.log

The script automatically corrects NICS(h)zz values for tilted rings by rotating the magnetic shielding tensor.  

Usage:
    python nics_map.py --help
"""

import os
import re
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import griddata
from matplotlib.colors import LinearSegmentedColormap
import argparse

# Function to parse coordinates from the input orientation section
def parse_coordinates(filepath):
    bq_pattern = re.compile(
    r"^\s*Bq\s+(-?\d+(?:\.\d*)?)\s+(-?\d+(?:\.\d*)?)\s+(-?\d+(?:\.\d*)?)\s*$"
    )
    
    atom_pattern = re.compile(
    r"^\s*([A-Z][a-z]?)\s+(-?\d+(?:\.\d*)?)\s+(-?\d+(?:\.\d*)?)\s+(-?\d+(?:\.\d*)?)\s*$"
    )
    
    dipole_pattern = re.compile(
    r"\s+X=\s+(-?\d+\.\d+)\s+Y=\s+(-?\d+\.\d+)\s+Z=\s+(-?\d+\.\d+)"    
    )
    
    bq_coordinates = []
    at_coordinates = []
    at_types = []
    dipole_moment = [0,0,0]
    with open(filepath, 'r') as file:
        for line in file:
            match = bq_pattern.match(line)
            if match:
                x, y, z = map(float, match.groups())
                bq_coordinates.append(np.array([x, y, z]))
            else:
                match = atom_pattern.match(line)
                if match:
                    at, x, y, z = match.groups()
                    at_coordinates.append(np.array([float(x), float(y), float(z)]))
                    at_types.append(at)
                else:
                    match = dipole_pattern.match(line)
                    if match:
                        x, y, z = map(float, match.groups())
                        dipole_moment = [x,y,z]                
                    
    numa = len(bq_coordinates)
    numa_zwei = len(at_coordinates)
    print(f"Atomic coords: {numa_zwei}, Bq coords: {numa}")  
    print(f"Dipole moment: X={dipole_moment[0]:.3f}, Y={dipole_moment[1]:.3f}, Z={dipole_moment[2]:.3f}")
    return bq_coordinates, at_coordinates, at_types, dipole_moment
     
def round_to_nearest_in_list(x):
    """
    Rounds a value to the closest value in a given list.
    
    Args:
        x (float): The value to round.
        values (list of float): The list of possible values to round to.
    
    Returns:
        float: The rounded value.
    """
    values = [0.1, 0.2, 0.25, 0.5, 1, 2, 2.5, 5, 10, 20]
    return min(values, key=lambda v: abs(x - v))
  
def create_colored_map_with_coords(results, filename, image_width, colors, vmin, vmax, coords, bonds, atom_colors, atom_sizes, iso_cont, nics_r, ticks_num, linew, no_legend, iso_not_zz, dipole_moment, show_dipole, or_atm, spec_atom):
    """
    Creates a colored 2D map of the "avg_zz_tilted" parameter from the "results" table 
    and overlays molecular coordinates with customizable colors and sizes.

    """
    # Extract data 
    x = np.array([result["X_proj"] for result in results])
    y = np.array([result["Y_proj"] for result in results])
    if not iso_not_zz: 
        z = np.array([result["avg_zz_tilted"] for result in results])
    else:
        z = np.array([result["avg_iso"] for result in results])
    
    #reorient so the spec_actom is in lower left part (if there is one spec_atom)
    N_number = 0 
    for cor in coords:
        if cor[0] == spec_atom:
            N_number += 1
            nitro_coords = ((cor[1],cor[2]))
      
    #reorient with the dipole moment    
    New_coords = []
    if np.linalg.norm(dipole_moment) > 0.5 and not or_atm :
        
        xs = float(1.0)
        ys = float(1.0)
        
        if dipole_moment[0] > 0: 
            x = -x
            xs = -xs
            dipole_moment[0] = -dipole_moment[0]
                 
        if dipole_moment[1] > 0: 
            y = -y
            ys = -ys
            dipole_moment[1] = -dipole_moment[1]
        for cor in coords:
            New_coords.append((cor[0] , xs*cor[1] , ys*cor[2]))

        coords = New_coords
    #... or the spec_atom
    else:
        if N_number >= 1:
            N_vec_x = nitro_coords[0] - x.mean(axis=0)
            N_vec_y = nitro_coords[1] - y.mean(axis=0)
            xs = float(1.0)
            ys = float(1.0)
            
            if N_vec_x > 0:
                x = -x
                xs = -xs
                dipole_moment[0] = -dipole_moment[0]
                     
            if N_vec_y > 0:
                y = -y
                ys = -ys
                dipole_moment[1] = -dipole_moment[1]
            for cor in coords:
                New_coords.append((cor[0] , xs*cor[1] , ys*cor[2]))

            coords = New_coords
       
    #set ticks        
    ticks_cor = []
    ticks_val = []
    span = float(vmax - vmin)
    delta = 0.5 * span / float(ticks_num)
    delta = round_to_nearest_in_list(delta)
    
    n_ticks = int(0.5 * span/delta)
    span = 2 * delta * float(n_ticks)
    
    n_rest = int(10 * delta) % 10
    vmin = -delta * float(n_ticks)
    vmax = -vmin
    for t in np.linspace(0, 1,int(2 * n_ticks + 1)):
        ticks_cor.append(t)
        val = vmin + t * span
        if n_rest > 0: 
            ticks_val.append(f"{val:.1f}") 

        else: ticks_val.append(f"{val:.0f}")

    
    # Normalize z values to range [0, 1]
    z_normalized = (z - vmin) / (vmax - vmin)
    z_normalized = np.clip(z_normalized, 0, 1)

    # Create a custom colormap from the given colors
    N = 256 * len(colors)
    cmap = LinearSegmentedColormap.from_list("custom_cmap", colors, N=N)
    
    image_height = int(float(image_width) * float((y.max() - y.min()) / (x.max() - x.min())))
    # Interpolate data onto a grid using Delaunay triangulation for efficiency
    grid_x, grid_y = np.linspace(x.min(), x.max(), image_width), np.linspace(
        y.min(), y.max(), int(image_height)
    )

    grid_z = griddata((x, y), z_normalized, (grid_x[None, :], grid_y[:, None]), method="cubic")
    
    # Create the plot
    
    if int(nics_r * 10) % 10 > 0:
        nics_type = f"NICS({nics_r:.1f})zz"
    else: nics_type = f"NICS({nics_r:.0f})zz"
    
    if iso_not_zz:
        nics_type = nics_type.replace("zz", "iso")
    
    plt.figure(figsize=(float(image_width) / float(150), float(image_height) / float(150)))  # Convert pixels to inches for figsize
    plt.imshow(grid_z, extent=(x.min(), x.max(), y.min(), y.max()), origin="lower", cmap=cmap, aspect="auto", vmin=0, vmax=1)
    cbar = plt.colorbar(label=nics_type)

    # Add contour lines
    if iso_cont: 
        contours = plt.contour(grid_x, grid_y, grid_z, levels=ticks_cor, colors="#EEEEEE", linewidths=linew) # alpha=0.8, 

    cbar.set_ticks(ticks_cor)
    cbar.set_ticklabels(ticks_val)
    
    plt.title(f"2D {nics_type}")
    plt.xlabel("X (Å)")
    plt.ylabel("Y (Å)")
    plt.gca().set_aspect("equal", adjustable="box")

    for bond in bonds:
        _, x1, y1 = coords[bond[0]]
        _, x2, y2 = coords[bond[1]]
        if(grid_x.min() <= x1 <= grid_x.max()) and (grid_y.min() <= y1 <= grid_y.max()) and (grid_x.min() <= x2 <= grid_x.max()) and (grid_y.min() <= y2 <= grid_y.max()):
            plt.plot([x1, x2], [y1, y2], color="black", linewidth=1.0, zorder=5)   
    
    # Overlay molecular coordinates
    for atom, x_coord, y_coord in coords:
        color = atom_colors.get(atom, "black")  # Default to black if atom type is not in the dictionary
        size = atom_sizes.get(atom, 30)        # Default size of 30 if atom type is not in the dictionary
        if(grid_x.min() <= x_coord <= grid_x.max()) and (grid_y.min() <= y_coord <= grid_y.max()):
            plt.scatter(x_coord, y_coord, color=color, s=size, label=atom, edgecolor='black', zorder=10)

    dipole_scale = -0.2082 #scaled down and reversed as in chemical convention -0.2082 for 1A separation of 1e charges
    if show_dipole and np.linalg.norm(dipole_moment) > 0.5:
        dx = dipole_scale * dipole_moment[0]
        dy = dipole_scale * dipole_moment[1]
        x1 = -dx/2
        x2 = -x1
        y1 = -dy/2
        y2 = -y1

        plt.arrow(x1, y1, dx, dy, head_width=0.2, head_length=0.3, fc="#00AA00", ec="#00AA00", linewidth=6, alpha=0.8, zorder=15)   

    # Avoid repeating labels in the legend
    handles, labels = plt.gca().get_legend_handles_labels()
    unique = dict(zip(labels, handles))
    if not no_legend:
        plt.legend(unique.values(), unique.keys(), loc="upper right", fontsize="medium")

    # Save the figure as a PNG file
    plt.savefig(filename, dpi=150, bbox_inches="tight")
      
    print(f"Saved: {filename}\n")
    plt.close()
   

# Function to parse shielding tensors from Gaussian log files
def parse_shielding_data(filepath):
    with open(filepath, 'r') as file:
        content = file.read()

    # Regular expression to find Bq atom data (shielding tensors)
    bq_pattern = re.compile(
        r"\s+(\d+)\s+Bq\s+Isotropic\s+=\s+([\d\-.]+)\s+Anisotropy\s+=\s+[\d\-.]+.*?"
        r"XX=\s+([\d\-.]+)\s+YX=\s+([\d\-.]+)\s+ZX=\s+([\d\-.]+).*?"
        r"XY=\s+([\d\-.]+)\s+YY=\s+([\d\-.]+)\s+ZY=\s+([\d\-.]+).*?"
        r"XZ=\s+([\d\-.]+)\s+YZ=\s+([\d\-.]+)\s+ZZ=\s+([\d\-.]+)",
        re.DOTALL
    )

    bq_data = []
    for match in bq_pattern.finditer(content):
        atom_index = int(match.group(1))
        isotropic = float(match.group(2))
        
        tensor = np.array([
            [float(match.group(3)), float(match.group(4)), float(match.group(5))],
            [float(match.group(6)), float(match.group(7)), float(match.group(8))],
            [float(match.group(9)), float(match.group(10)), float(match.group(11))]
        ])
        bq_data.append((atom_index, isotropic, tensor))
   
    numa = len(bq_data)
    print(f"Shielding data: {numa}")     
    return bq_data


# Function to calculate tilt-adjusted shielding
def calculate_tilted_shielding(bq_data,coords):
    results = []
    avg_con_vec_len = 0
    n_bq_pairs = 0
    
    for i in range(0, len(bq_data), 2):
        # Extract data for the Bq atom pair
        _, iso1, tensor1 = bq_data[i]
        _, iso2, tensor2 = bq_data[i + 1]
        coords1 = coords[i]
        coords2 = coords[i + 1]
        
        # Calculate vector connecting the pair and normalize it
        connecting_vector = coords2 - coords1
        con_vec_len = np.linalg.norm(connecting_vector)
        norm_vector = connecting_vector / con_vec_len
        avg_con_vec_len += con_vec_len
        # Calculate the central position between the Bq points
        centroid = (coords1 + coords2) / 2
        x_pr = np.dot(centroid,[1,0,0])
        y_pr = np.dot(centroid,[0,1,0])

        # Calculate the isotropic shielding and adjusted ZZ component
        avg_iso = -0.5 * (iso1 + iso2)
        
        
        # Adjust the ZZ components
        zz1 = norm_vector @ tensor1 @ norm_vector
        zz2 = norm_vector @ tensor2 @ norm_vector
        avg_zz_tilted = -0.5 * (zz1 + zz2)
        
        zz1 = -0.5*(tensor1[2][2] + tensor2[2][2])
        # Add the path length contribution

        results.append({
            "X_proj": x_pr,
            "Y_proj": y_pr,
            "avg_iso": avg_iso,
            "avg_zz_tilted": avg_zz_tilted,
            "avg_zz_original": zz1
        })
        n_bq_pairs += 1
    
    if n_bq_pairs > 0:
        avg_con_vec_len /= n_bq_pairs * 2
    
    return results, avg_con_vec_len

# Function to write the output file
def write_results(filepath, results):
    output_file = filepath.replace(".log", ".txt")
    num_bq = 2 * len(results)

    with open(output_file, 'w') as file:
        file.write(f"Bq points: {num_bq}\n")
        file.write("\nX_proj Y_proj NICS_iso NICS_ZZ_tilted NICS_ZZ_original\n")
        for result in results:
            file.write(f"{result['X_proj']:.6f} {result['Y_proj']:.6f} {result['avg_iso']:.6f} {result['avg_zz_tilted']:.6f} {result['avg_zz_original']:.6f}\n")

        
# Main script

parser = argparse.ArgumentParser(description="Generate a map based on NICS data.")
parser.add_argument("--cont-map", dest="iso_cont", action="store_true", help="Add contour map")
parser.add_argument("--no-legend", dest="no_legend", action="store_true", help="Remove legend")
parser.add_argument("--dipole", dest="show_dipole", action="store_true", help="Show dipole moment")
parser.add_argument("--iso", dest="iso_not_zz", action="store_true", help="Calculate isotropic shielding instead of ZZ")
parser.add_argument("--m", type=float, default=35, help="Max and min NICS(h)zz values (default: 35).")
parser.add_argument("--nt", type=int, default=8, help="Number of ticks and contour lines - the same in positive and negative direction (default: 8).")
parser.add_argument("--lw", type=float, default=0.5, help="Linewidth for contour lines (default: 0.5).")
parser.add_argument("--orient-atom", dest="or_atm", action="store_true", help="Orient molecule placing selected atom in bottom left corner")
parser.add_argument("--atm", type=str, default="N", help="Atom to be in bottom left corner (default: N)")
parser.set_defaults(iso_cont=False)
parser.set_defaults(or_atm=False)
parser.set_defaults(iso_not_zz=False)
parser.set_defaults(show_dipole=False)
parser.set_defaults(no_legend=False)
args = parser.parse_args()

if args.iso_cont:
    yesno = f"be added (linewidth: {args.lw:.2f})"
else:
    yesno = "not be added"
    
if args.or_atm:
    atomium = f"Orientation by atom: {args.atm}."
else:
    atomium = "Orientation by dipole."    
    
print(f"Min and max NICS values: +/-{args.m}. Contour map will {yesno}. Number of ticks: {args.nt} (both sides). {atomium}")

input_folder = "."  # Use current folder


for filename in os.listdir(input_folder):
    nmp_yn = filename.endswith("NMP.log") or ((filename.find("-NMP")!=-1 or filename.find("-tNMP")!=-1) and filename.endswith(".log"))
             
    if nmp_yn:
        filepath = os.path.join(input_folder, filename)
        file_png=filepath
        file_png = file_png.replace(".log", ".png")
        print(f"Opened: {filename}")
        # Parse the coordinates and shielding data
        bq_coordinates, at_coords, at_types, dipole_moment = parse_coordinates(filepath)
        bq_data = parse_shielding_data(filepath)
        

        at_proj_coords = []
        
        for at,atty in zip(at_coords,at_types):
            x_pr = at[0]
            y_pr = at[1]
            at_proj_coords.append((atty,x_pr,y_pr))
   
        bond_info=[]
        
        for i, (x1, y1, z1) in enumerate(at_coords):
            for j, (x2, y2, z2) in enumerate(at_coords):
                if i >= j:
                    continue  # Avoid double calculation

                distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)
                max_distance = 1.3 if "H" in (at_types[i], at_types[j]) else 1.9

                if distance <= max_distance:
                    bond_info.append((i,j))
            
        # Calculate the adjusted shielding data
        if len(bq_coordinates) == len(bq_data):
            results, avg_h = calculate_tilted_shielding(bq_data,bq_coordinates)
            print(f"Average Bq elevation: {avg_h:.3f}")
        # Write the results to the output file
        write_results(filepath,  results)
        """create_colored_map(
            results, 
            file_png, 
            image_width=1600, 
            colors=[(0.05,0,0.6), (0, 0.2, 0.8), (1, 1, 1), (0.8, 0, 0), (0.5,0.1,0)],  # Blue to white to red
            vmin=-35, 
            vmax=35
        )"""
        
        atom_colors = {
            "C": "#666666",  # Grey
            "H": "#FFFFFF",  # White
            "O": "#FF0000",  # Red
            "N": "#0000FF",  # Blue
            "S": "#FFFF00",  # Yellow
            "P": "#FFA500",  # Orange
            "Si": "#00AAAA",
            "F": "#00FF00",  # Green
            "Cl": "#00FF00",  # Green
            "Br": "#8B0000",  # Dark red
            "B": "#FFB6C1",  # Peach
        }

        default_color = "#FFC0CB"  # Pink for any other element

        atom_sizes = {
            "C": 120,
            "H": 60,
            "O": 160,
            "N": 140,
            "S": 180,
            "P": 180,
            "Si": 180,
            "F": 120,
            "Cl": 140,
            "Br": 160,
            "B": 100,
        }
            
        color_space = [
            (0.12, 0.03, 0.39),
            (0.03, 0.04, 0.64),
            (0.05, 0.11, 0.98),
            (0.19, 0.68, 1),
            (0.73, 0.92, 1),
            (1, 1, 1),
            (1, 0.92, 0.73),
            (1, 0.68, 0.19),
            (0.98, 0.11, 0.05),
            (0.64, 0.04, 0.03),
            (0.39, 0.03, 0.12)
        ]
            
        create_colored_map_with_coords(
            results,
            file_png,
            image_width=2000,
            colors=color_space,
            vmin=-args.m,
            vmax=args.m,
            coords=at_proj_coords,
            bonds=bond_info,
            atom_colors=atom_colors,
            atom_sizes=atom_sizes,
            iso_cont=args.iso_cont,
            nics_r = avg_h,
            ticks_num = args.nt,
            linew = args.lw,
            no_legend = args.no_legend,
            iso_not_zz = args.iso_not_zz,
            dipole_moment = dipole_moment,
            show_dipole = args.show_dipole,
            or_atm = args.or_atm,
            spec_atom = args.atm
        )
